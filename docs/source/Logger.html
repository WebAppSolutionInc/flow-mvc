<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 Copyright (c) 2013 [Web App Solution, Inc.](mailto:admin@webappsolution.com)

 FlowMVC is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 FlowMVC is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with FlowMVC.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

<span id='FlowMVC-logger-Logger'>/**
</span> * This is a simple, one-class logger that attempts to do the bare minimum required for logging without a ton
 * of bells and whistles; simply put, this logger offers console logging as the only target, no filtering by context
 * or leg-level, and a fixed output that's not configurable. There are many other logging libraries that support this
 * type of advanced logging support: log4javascript http://log4javascript.org/, log4js-ext https://code.google.com/p/log4js-ext/
 * and so on.
 *
 * The logger provides a simple wrapper to the console but with some added benefits like checking for console
 * availability and parametrized variable substitution in logging messages using array or JSON notation as
 * the second parameter to the log statement. The output for the logger looks like:
 *
 * HH:MM:SS:SSS LEVEL [context or className] - message
 *
 * A fully backed example log message might look like:
 *
 * 22:07:44:968 DEBUG	[FlowMVC.mvc.event.AbstractEvent] - AbstractEvent.Constructor: type = flowMVCEvent
 *
 * Variable substitution with tokens is achieved with arrays:
 *
 * logger.debug(&quot;execute: first = {0}, last = {1}&quot;, [first, last]);
 *
 * OR with JSON:
 *
 * logger.debug(&quot;execute: name = {name}, last = {foo.bar}&quot;, { first:&quot;john doe&quot;, foo: { bar:&quot;foo-bar&quot; } });
 *
 * The logger does not currently allow you to edit the formatted output or filter by log level or category.
 */
Ext.define(&quot;FlowMVC.logger.Logger&quot;, {

	statics: {

<span id='FlowMVC-logger-Logger-property-isEnabled'>		/**
</span>		 * {Boolean} isEnabled Global flag indicating if logging is enabled.
		 */
		isEnabled: true,

<span id='FlowMVC-logger-Logger-property-LEVEL_LOG'>		/**
</span>		 * {String} LEVEL_LOG A constant. Indicates the &quot;log&quot; logging level.
		 */
		LEVEL_LOG: &quot;LOG&quot;,

<span id='FlowMVC-logger-Logger-property-LEVEL_DEBUG'>		/**
</span>		 * {String} LEVEL_DEBUG A constant. Indicates the &quot;debug&quot; logging level.
		 */
		LEVEL_DEBUG: &quot;DEBUG&quot;,

<span id='FlowMVC-logger-Logger-property-LEVEL_INFO'>		/**
</span>		 * {String} LEVEL_INFO A constant. Indicates the &quot;info&quot; logging level.
		 */
		LEVEL_INFO: &quot;INFO&quot;,

<span id='FlowMVC-logger-Logger-property-LEVEL_WARN'>		/**
</span>		 * {String} LEVEL_WARN A constant. Indicates the &quot;warn&quot; logging level.
		 */
		LEVEL_WARN: &quot;WARN&quot;,

<span id='FlowMVC-logger-Logger-property-LEVEL_ERROR'>		/**
</span>		 * {String} LEVEL_ERROR A constant. Indicates the &quot;error&quot; logging level.
		 */
		LEVEL_ERROR: &quot;ERROR&quot;,

<span id='FlowMVC-logger-Logger-property-LEVEL_FATAL'>		/**
</span>		 * {String} LEVEL_FATAL A constant. Indicates the &quot;fatal&quot; logging level.
		 */
		LEVEL_FATAL: &quot;FATAL&quot;,

<span id='FlowMVC-logger-Logger-method-getLogger'>		/**
</span>		 * Creates a logger that outputs the following format:
		 *
		 * 16:11:45:956 DEBUG [CafeTownsend.controller.AuthenticationController] - login: username = a, password = a
		 *
		 * @param {String} context The string name used for the logger. This is often the class name of the object the
		 * logger is used in.
		 * @returns {FlowMVC.logger.Logger} A FlowMVC logger.
		 */
		getLogger: function(context) {
			var logger;

			if(!Ext.isString(context)) {
				context = Ext.getClassName(context);
			}

			if ((context == null) || (context == &quot;undefined&quot;) || (context == &quot;&quot;)) {
				context = &quot;Unknown Context&quot;;
			}

			return Ext.create(&quot;FlowMVC.logger.Logger&quot;, context);
		},

<span id='FlowMVC-logger-Logger-method-getInjectableLogger'>		/**
</span>		 * Returns an object of the logger as a factory so it can be injected into client objects. The factory is used
		 * so we can use the reference to the instance of the object it's injected into, thus allowing log messages
		 * to take the following format:
		 *
		 * 16:11:45:956 DEBUG [CafeTownsend.controller.AuthenticationController] - login: username = a, password = a
		 *
		 * The use of the singleton property of the returned object ensures that the logger is unique and created
		 * for each injection, again allowing the logger to gain a reference to the instance it's injected into.
		 *
		 * @returns {{fn: Function, singleton: boolean}}
		 */
		getInjectableLogger: function() {

			return {
				// The factory function will be passed a single argument:
				// The object instance that the new object will be injected into
				// NOTE: the factory function for DeftJS must be named &quot;fn&quot;
				fn: function(instance) {
					return FlowMVC.logger.Logger.getLogger(instance);
				},
				singleton: false
			}
		}
	},

<span id='FlowMVC-logger-Logger-property-context'>	/**
</span>	 * {String} context String name to be used when logging; typically this is the client object's fully-qualified name.
	 */
	context: null,

<span id='FlowMVC-logger-Logger-method-constructor'>	/**
</span>	 * Constructor.
	 *
	 * @param {String} context The context is a string indicator used when logging with this logger;
	 * often times this is the class name of the client object using this logger.
	 */
	constructor: function(context) {
		this.context = context;
	},

<span id='FlowMVC-logger-Logger-method-log'>	/**
</span>	 * Provides logging with a level of &quot;log&quot;.
	 */
	log: function() {
		this.internalLog(FlowMVC.logger.Logger.LEVEL_LOG, arguments);
	},

<span id='FlowMVC-logger-Logger-method-debug'>	/**
</span>	 * Provides logging with a level of &quot;debug&quot;.
	 */
	debug: function() {
		this.internalLog(FlowMVC.logger.Logger.LEVEL_DEBUG, arguments);
	},

<span id='FlowMVC-logger-Logger-method-info'>	/**
</span>	 * Provides logging with a level of &quot;info&quot;.
	 */
	info: function() {
		this.internalLog(FlowMVC.logger.Logger.LEVEL_INFO, arguments);
	},

<span id='FlowMVC-logger-Logger-method-warn'>	/**
</span>	 * Provides logging with a level of &quot;warn&quot;.
	 */
	warn: function() {
		this.internalLog(FlowMVC.logger.Logger.LEVEL_WARN, arguments);
	},

<span id='FlowMVC-logger-Logger-method-error'>	/**
</span>	 * Provides logging with a level of &quot;error&quot;.
	 */
	error: function() {
		this.internalLog(FlowMVC.logger.Logger.LEVEL_ERROR, arguments);
	},

<span id='FlowMVC-logger-Logger-method-fatal'>	/**
</span>	 * Provides logging with a level of &quot;fatal&quot;.
	 */
	fatal: function() {
		this.internalLog(FlowMVC.logger.Logger.LEVEL_FATAL, arguments);
	},

<span id='FlowMVC-logger-Logger-method-getTimestamp'>	/**
</span>	 * Creates a print-friendly timestamp in the form of 16:11:45:956 for logging purposes.
	 *
	 * @return {String} A timestamp in the form of 16:11:45:956.
	 */
	getTimestamp: function() {

		var date = new Date();
		var hours = date.getHours();
		var minutes = date.getMinutes();
		var seconds = date.getSeconds();
		var milliseconds = date.getMilliseconds();

		if (hours &lt; 10) {
			hours = &quot;0&quot; + hours;
		}

		if (minutes &lt; 10) {
			minutes = &quot;0&quot; + minutes;
		}

		if (seconds &lt; 10) {
			seconds = &quot;0&quot; + seconds;
		}

		if (milliseconds &lt; 10) {
			milliseconds = &quot;00&quot; + milliseconds;
		} else if (milliseconds &lt; 100) {
			milliseconds = &quot;0&quot; + milliseconds;
		}

		return hours + &quot;:&quot; + minutes + &quot;:&quot; + seconds + &quot;:&quot; + milliseconds;
	},

<span id='FlowMVC-logger-Logger-method-getPrintFriendlyLogStatement'>	/**
</span>	 * Creates a print-friendly context in the form of
	 * 16:11:45:956 DEBUG [CafeTownsend.controller.AuthenticationController] - login: username = {a}, password = {b}
	 * for logging purposes, where {a} and {b} are tokenized parameters passed into the logging method.
	 *
	 * @return {String} A context in the form of 16:11:45:956 DEBUG [CafeTownsend.controller.AuthenticationController]
	 * - login: username = {a}, password = {b}.
	 */
	getPrintFriendlyLogStatement: function(level, msg) {
		return this.getTimestamp() + &quot; &quot; + level + &quot;\t&quot; + &quot;[&quot; + this.context + &quot;]&quot; + &quot; - &quot; + msg;
	},

<span id='FlowMVC-logger-Logger-method-replaceTokens'>	/**
</span>	 * Determines if the token value object (second parameter in the original log function) is an array or object
	 * and attempts to perform token substitution based on the valuers in the array or JSON object. Tokens in the
	 * message either looks like {0}, {1}, ... {n} for array substitution or {user.username}, {firstName} for
	 * JSON substitution.
	 *
	 * @return {String} The final message with tokens replaced with values.
	 */
	replaceTokens: function(args, msg) {
		var tokenValues = args[1];

		// do substitution of tokens with the passed in array of values
		if (Ext.isArray(tokenValues)) {
			var len = tokenValues.length;
			for (var i = 0; i &lt; len; i++) {
				msg = msg.replace(new RegExp(&quot;\\{&quot; + i + &quot;\\}&quot;, &quot;g&quot;), tokenValues[i]);
			}

		// do substitution of tokens using the passed in JSON object
		} else if (Ext.isObject(tokenValues)) {
			var tokens = msg.match(/\{(.*?)\}/g);
			if(Ext.isArray(tokens)) {

				var value = &quot;&quot;;
				var len = tokens.length;

				// loop through all the tokens and repalace them with values from the JSON object
				for (var j = 0; j &lt; len; j++) {

					// replace the brackets for &quot;{user.username}&quot; becomes &quot;user.username&quot;
					var token = tokens[j].replace(/\{(.*?)\}/g,&quot;$1&quot;);
					// create an array of all the tokens
					var properties = token.split(&quot;.&quot;);

					// nested function to dig down into a JSON object and grab the actual value of the nested property
					// allows for the retrieval of a json object like foo.bar.count.
					getNestedValue = function(tokenValues, properties) {

						var property = &quot;&quot;;
						var len = properties.length;
						for (var j = 0; j &lt; len; j++) {
							property = properties[j];
							tokenValues = tokenValues[property];
						}
						return tokenValues;
					}

					try {
						value = getNestedValue(tokenValues, properties);
					} catch(e) {
						value = &quot;&quot;;
					};

					msg = msg.replace(new RegExp(tokens[j]), value);
				}
			}
		}

		return msg;
	},

<span id='FlowMVC-logger-Logger-method-internalLog'>	/**
</span>	 * @private Determines the log level and logs to the console accordingly. Can take tokenized log messages and substitute
	 * values passed into the logging method.
	 *
	 * @param {String} level The logging level.
	 * @param {Array} args An array of logging arguments. The first argument is typically the message and the following
	 * can be used in log message token substitution.
	 */
	internalLog: function(level, args) {

		// do not log anything if logging is not enabled
		if (!FlowMVC.logger.Logger.isEnabled) {
			return;
		}

		// get the console print friendly message
		var msg = this.getPrintFriendlyLogStatement(level, args[0]);

		// determine if the message has parametrized tokens
		if(args &amp;&amp; (args.length &gt;= 2)) {
			msg = this.replaceTokens(args, msg);
		}

		// determine the log level and log to the console accordingly
		// TODO: Might want to consider using Ext.Logger() or something that handles console logging with IE
		switch (level) {
			case FlowMVC.logger.Logger.LEVEL_INFO:
				try {
					if(window.console &amp;&amp; console.info &amp;&amp; Ext.isFunction(console.info)) {
						console.info(msg);
					}
				} catch (e) {
				}
				break;

			case FlowMVC.logger.Logger.LEVEL_WARN:
				try {
					if(window.console &amp;&amp; console.warn &amp;&amp; Ext.isFunction(console.warn)) {
						console.warn(msg);
					}
				} catch (e) {
				}
				break;

			case FlowMVC.logger.Logger.LEVEL_ERROR:
			case FlowMVC.logger.Logger.LEVEL_FATAL:
				try {
					if(window.console &amp;&amp; console.error &amp;&amp; Ext.isFunction(console.error)) {
						console.error(msg);
					}
				} catch (e) {
				}
				break;

			case FlowMVC.logger.Logger.LEVEL_LOG:
			case FlowMVC.logger.Logger.LEVEL_DEBUG:
			default:
				try {
					if(window.console &amp;&amp; console.debug &amp;&amp; Ext.isFunction(console.debug)) {
						console.debug(msg);
					}
				} catch (e) {
				}
				break;
		}

	}

});
</pre>
</body>
</html>
